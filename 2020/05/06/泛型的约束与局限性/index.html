<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>泛型的约束与局限性 - Lehirt&#039;s Blog</title><meta description="由于类型擦除的原因和影响，使用java泛型时有一些限制。"><meta property="og:type" content="blog"><meta property="og:title" content="泛型的约束与局限性"><meta property="og:url" content="https://lehirt.github.io/2020/05/06/%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%BA%A6%E6%9D%9F%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7/"><meta property="og:site_name" content="Lehirt&#039;s Blog"><meta property="og:description" content="由于类型擦除的原因和影响，使用java泛型时有一些限制。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://lehirt.github.io/img/og_image.png"><meta property="article:published_time" content="2020-05-06T13:56:39.000Z"><meta property="article:modified_time" content="2020-05-08T02:22:09.564Z"><meta property="article:author" content="lehirt"><meta property="article:tag" content="javaSE"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://lehirt.github.io/2020/05/06/%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%BA%A6%E6%9D%9F%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7/"},"headline":"Lehirt's Blog","image":["https://lehirt.github.io/img/og_image.png"],"datePublished":"2020-05-06T13:56:39.000Z","dateModified":"2020-05-08T02:22:09.564Z","author":{"@type":"Person","name":"lehirt"},"description":"由于类型擦除的原因和影响，使用java泛型时有一些限制。"}</script><link rel="canonical" href="https://lehirt.github.io/2020/05/06/%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%BA%A6%E6%9D%9F%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7/"><link rel="icon" href="/images/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/avatar.png" alt="Lehirt&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Lehirt"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-05-06T13:56:39.000Z" title="2020-05-06T13:56:39.000Z">2020-05-06</time><span class="level-item"><a class="link-muted" href="/categories/java/">java</a></span><span class="level-item">14 分钟 读完 (大约 2080 个字)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">泛型的约束与局限性</h1><div class="content"><p>由于<strong>类型擦除</strong>的原因和影响，使用java泛型时有一些限制。</p>
<a id="more"></a>
<h3 id="不能用基本类型实例化类型参数"><a href="#不能用基本类型实例化类型参数" class="headerlink" title="不能用基本类型实例化类型参数"></a>不能用基本类型实例化类型参数</h3><p>不能用类型参数代替基本类型。因此， 没有 <code>Pair&lt;double&gt;</code>, 只有 <code>Pair&lt;Double&gt;</code>。 当然, 其原因是类型擦除。擦除之后， Pair 类含有 Object 类型的域， 而 Object 不能存储 double 值。</p>
<h3 id="运行时类型查询只适用于原始类型"><a href="#运行时类型查询只适用于原始类型" class="headerlink" title="运行时类型查询只适用于原始类型"></a>运行时类型查询只适用于原始类型</h3><p>虚拟机中的对象<strong>总有一个特定的非泛型类型</strong>。也就是说，虚拟机中的对象都是非泛型化的类型。因此，所有的<strong>类型查询</strong>只产生原始类型。</p>
<p>举个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; a =<span class="keyword">new</span> Pair&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p>因为类型擦除之后,Pair<String>只剩下原始类型，泛型信息String不存在了。</p>
<p>那么，运行时进行类型查询的时候使用下面的方法是错误的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a <span class="keyword">instanceof</span> Pair&lt;String&gt;) <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>实际上仅仅测试 a 是否是任意类型的一个 <code>Pair</code>。试图查询一个对象是否属于<strong>某个泛型类型</strong>时，倘若使用 <code>instanceof</code> 会得到一个编译器错误，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( arrayList <span class="keyword">instanceof</span> Pair&lt;?&gt;)</span><br></pre></td></tr></table></figure>

<p>再看强制类型转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; p = (Pair&lt;String&gt;) a; <span class="comment">// Warning-can only test that a is a Pair</span></span><br></pre></td></tr></table></figure>
<p>如果使用强制类型转换会得到一个警告。 </p>
<p>同样的道理，<code>getClass</code> 方法总是返回原始类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; stringPair = <span class="keyword">new</span> Pair&lt;String&gt;();</span><br><span class="line">Pair&lt;Employee&gt; employeePair = <span class="keyword">new</span> Pair&lt;Employee&gt;(); </span><br><span class="line"><span class="keyword">if</span> (stringPair.getClass() == employeePair.getClass()) <span class="comment">// they are equal </span></span><br><span class="line"><span class="comment">//两次调用getClass()都返回Pair.class</span></span><br></pre></td></tr></table></figure>

<h3 id="不能创建参数化类型的数组"><a href="#不能创建参数化类型的数组" class="headerlink" title="不能创建参数化类型的数组"></a>不能创建参数化类型的数组</h3><p>不能声明参数化类型的数组。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;[] table = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<p>这有什么问题呢？ 擦除之后， table 的类型是 Pair[ ]。可以把它转换为Object: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] objarray = table;</span><br></pre></td></tr></table></figure>
<p>数组会记住它的元素类型， 如果试图存储其他类型的元素， 就会抛出一个 ArrayStoreException 异常： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objarray[<span class="number">0</span>] = <span class="string">"Hello"</span>; <span class="comment">// Error component type is Pair</span></span><br></pre></td></tr></table></figure>

<p>对于泛型而言，擦除降低了这个机制的效率。下面的赋值可以通过数组存储的检测，但仍然会导致类型错误。出于这个原因，<strong>不允许创建参数化类型的数组</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objarray[<span class="number">0</span>] = <span class="keyword">new</span> Pair&lt;Employee&gt;()；</span><br></pre></td></tr></table></figure>

<p>需要说明的是， 只是不允许创建这些数组， 而声明类型为<code>Pair&lt;String&gt;[]</code>的变量仍是合法的。不过不能用<code>new Pair&lt;String&gt;[10]</code>初始化这个变量。如果需要收集参数化类型对象，只有一种安全而有效的方法:<strong>使用 ArrayList:ArrayList&lt;Pair<String>()</strong>.</p>
<h3 id="Varargs-警告"><a href="#Varargs-警告" class="headerlink" title="Varargs 警告"></a>Varargs 警告</h3><p>如果向参数个数可变的方法传递一个泛型类型的实例。例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collections coll, T... ts)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">for</span> (t : ts) coll.add(t)； </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//应该记得，实际上参数 ts 是一个数组， 包含提供的所有实参。 现在考虑以下调用：</span></span><br><span class="line"></span><br><span class="line">Col1ection&lt;Pair&lt;String&gt; table = . . .; </span><br><span class="line">Pair&lt;String&gt; pairl = ...; </span><br><span class="line">Pair&lt;String&gt; pair2 = ...;</span><br><span class="line">addAll(table, pairl, pair2);</span><br></pre></td></tr></table></figure>
<p>为了调用这个方法，Java 虚拟机必须建立一个 <code>Pair&lt;String&gt;</code>数组， 这就违反了上一节中不能有泛型类型数组的规则。不过，对于这种情况，规则有所放松，你只会得到一个警告，而不是错误。</p>
<h3 id="不能实例化类型变量"><a href="#不能实例化类型变量" class="headerlink" title="不能实例化类型变量"></a>不能实例化类型变量</h3><p>不能实例化泛型类型。如，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first = <span class="keyword">new</span> T(); <span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>
<p>是错误的，类型擦除会使这个操作做成new Object()。</p>
<p>不能建立一个泛型数组。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>&lt;T&gt; T[] minMax(T[] a)&#123;  </span><br><span class="line">     T[] mm = <span class="keyword">new</span> T[<span class="number">2</span>]; <span class="comment">//ERROR  </span></span><br><span class="line">     ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似的，擦除会使这个方法总是构靠一个Object[2]数组。</p>
<p>但是，可以用反射构造泛型对象和数组。</p>
<p>利用反射，调用Array.newInstance:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">publicstatic &lt;T extends Comparable&gt; T[]minmax(T[] a) &#123;  </span><br><span class="line">      T[] mm == (T[])Array.newInstance(a.getClass().getComponentType(),<span class="number">2</span>);   </span><br><span class="line">       ...    </span><br><span class="line">      <span class="comment">// 以替换掉以下代码    </span></span><br><span class="line">      <span class="comment">// Obeject[] mm = new Object[2];    </span></span><br><span class="line">      <span class="comment">// return (T[]) mm;    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型类的静态上下文中类型变量无效"><a href="#泛型类的静态上下文中类型变量无效" class="headerlink" title="泛型类的静态上下文中类型变量无效"></a>泛型类的静态上下文中类型变量无效</h3><p>泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数。</p>
<p>举例说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span>&lt;<span class="title">T</span>&gt; </span>&#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T one;   <span class="comment">//编译错误    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  T <span class="title">show</span><span class="params">(T one)</span></span>&#123; <span class="comment">//编译错误    </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为泛型类中的泛型参数的实例化是在定义对象的时候指定的，而静态变量和静态方法不需要使用对象来调用。对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误的。</p>
<p>但是要注意区分下面的一种情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span>&lt;<span class="title">T</span>&gt; </span>&#123;      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T &gt;<span class="function">T <span class="title">show</span><span class="params">(T one)</span></span>&#123;<span class="comment">//这是正确的    </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为这是一个泛型方法，在泛型方法中使用的T是自己在方法中定义的T，而不是泛型类中的T。</p>
<h3 id="不能抛出或捕获泛型类的实例"><a href="#不能抛出或捕获泛型类的实例" class="headerlink" title="不能抛出或捕获泛型类的实例"></a>不能抛出或捕获泛型类的实例</h3><p>1、不能抛出也不能捕获泛型类的对象。事实上，泛型类扩展Throwable都不合法。例如：下面的定义将不会通过编译：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;......&#125;  <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>为什么不能扩展Throwable，因为异常都是在运行时捕获和抛出的，而在编译的时候，泛型信息全都会被擦除掉，那么，假设上面的编译可行，那么，在看下面的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     </span><br><span class="line">&#125;<span class="keyword">catch</span>(Problem&lt;Integer&gt; e1)&#123;  </span><br><span class="line">   。。  </span><br><span class="line">&#125;<span class="keyword">catch</span>(Problem&lt;Number&gt; e2)&#123;  </span><br><span class="line">   ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型信息被擦除后，那么两个地方的catch都变为原始类型Object，那么也就是说，这两个地方的catch变的一模一样,就相当于下面的这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;  </span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(Problem&lt;Object&gt; e1)&#123;  </span><br><span class="line">    。。  </span><br><span class="line">&#125;<span class="keyword">catch</span>(Problem&lt;Object&gt; e2)&#123;  </span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个当然就是不行的。就好比，catch两个一模一样的普通异常，不能通过编译一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;  </span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e1)&#123;  </span><br><span class="line">   。。  </span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception  e2)&#123;<span class="comment">//编译错误  </span></span><br><span class="line">   ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、不能在catch子句中使用泛型变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span></span>&#123;  </span><br><span class="line">   <span class="keyword">try</span>&#123;  </span><br><span class="line">        ...  </span><br><span class="line">   &#125;<span class="keyword">catch</span>(T e)&#123; <span class="comment">//编译错误  </span></span><br><span class="line">        ...  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为泛型信息在编译的时候已经变味原始类型，也就是说上面的T会变为<strong>限定类型Throwable</strong>，那么如果可以在catch子句中使用泛型变量，那么，下面的定义呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            ...  </span><br><span class="line">        &#125;<span class="keyword">catch</span>(T e)&#123; <span class="comment">//编译错误  </span></span><br><span class="line">            ...  </span><br><span class="line">        &#125;<span class="keyword">catch</span>(IndexOutOfBounds e)&#123; </span><br><span class="line"> </span><br><span class="line">        &#125;                           </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>根据异常捕获的原则，一定是子类在前面，父类在后面，那么上面就违背了这个原则。即使你在使用该静态方法的使用T是 ArrayIndexOutofBounds，在编译之后还是会变成Throwable，ArrayIndexOutofBounds是 IndexOutofBounds的子类，违背了异常捕获的原则。所以java为了避免这样的情况，禁止在catch子句中使用泛型变量。</p>
<p>但是<strong>在异常声明中可以使用类型变量</strong>。即可以在throws子句声明中正常使用类型变量，下面方法是合法的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T</span>&#123;  </span><br><span class="line">    <span class="keyword">try</span>&#123;  </span><br><span class="line">        ...  </span><br><span class="line">    &#125;<span class="keyword">catch</span>(Throwable realCause)&#123;  </span><br><span class="line">        t.initCause(realCause);  </span><br><span class="line">        <span class="keyword">throw</span> t;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的这样使用是没问题的。</p>
<h3 id="注意擦除后的冲突"><a href="#注意擦除后的冲突" class="headerlink" title="注意擦除后的冲突"></a>注意擦除后的冲突</h3><p>1、当泛型类型被擦除后，创建条件不能产生冲突。如果在Pair类中添加下面的equals方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;   </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T value)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑一个Pair<String>。从概念上，它有两个equals方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(String)</span></span>; <span class="comment">//在Pair&lt;T&gt;中定义</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object)</span></span>; <span class="comment">//从object中继承</span></span><br></pre></td></tr></table></figure>
<p>但是，这只是一种错觉。实际上，擦除后方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变成了方法 <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object)</span></span></span><br></pre></td></tr></table></figure>

<p>这与Object.equals方法是冲突的！当然，<strong>补救的办法是重新命名引发错误的方法</strong>。</p>
<p>2、泛型规范说明提及另一个原则“要支持擦除的转换，需要强行制一个类或者类型变量不能同时成为两个接口的子类，而这两个子类是同一接口的不同参数化。”</p>
<p>下面的代码是非法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calendar</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Calendar</span>&gt;</span>&#123; ... &#125; </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GregorianCalendar</span> <span class="keyword">extends</span> <span class="title">Calendar</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">GregorianCalendar</span>&gt;</span>&#123;...&#125; <span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>
<p>GregorianCalendar会实现Comparable<Calender>和Compable<GregorianCalendar>，这是同一个接口的不同参数化实现。</p>
<p>这一限制与类型擦除的关系并不很明确。非泛型版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calendar</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123; ... &#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GregorianCalendar</span> <span class="keyword">extends</span> <span class="title">Calendar</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;...&#125; <span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>
<p>是合法的。</p>
</div><div class="article-tags size-small is-uppercase mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/javaSE/">javaSE</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/05/07/%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BB%A7%E6%89%BF%E8%A7%84%E5%88%99%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">泛型类型的继承规则和通配符类型的使用</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/05/05/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E5%92%8C%E6%A1%A5%E6%96%B9%E6%B3%95/"><span class="level-item">java中的类型擦除和桥方法</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="" src="/images/avatar.png" alt="Lehirt"></figure><p class="title is-size-4 is-block line-height-inherit">Lehirt</p><p class="is-size-6 is-block">Lehirt&#039;s Blog</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>孤独星人</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">26</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">12</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Lehirt" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Lehirt"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/avatar.png" alt="Lehirt&#039;s Blog" height="28"></a><p class="size-small"><span>&copy; 2020 lehirt</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Lehirt"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://lehirt.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>